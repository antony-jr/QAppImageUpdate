
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>appimageupdateinformation_p.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * BSD 3-Clause License</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2018-2019, Antony jr</a>
<a name="ln5"> * All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln8"> * modification, are permitted provided that the following conditions are met:</a>
<a name="ln9"> *</a>
<a name="ln10"> * * Redistributions of source code must retain the above copyright notice, this</a>
<a name="ln11"> *   list of conditions and the following disclaimer.</a>
<a name="ln12"> *</a>
<a name="ln13"> * * Redistributions in binary form must reproduce the above copyright notice,</a>
<a name="ln14"> *   this list of conditions and the following disclaimer in the documentation</a>
<a name="ln15"> *   and/or other materials provided with the distribution.</a>
<a name="ln16"> *</a>
<a name="ln17"> * * Neither the name of the copyright holder nor the names of its</a>
<a name="ln18"> *   contributors may be used to endorse or promote products derived from</a>
<a name="ln19"> *   this software without specific prior written permission.</a>
<a name="ln20"> *</a>
<a name="ln21"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</a>
<a name="ln22"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln23"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</a>
<a name="ln24"> * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</a>
<a name="ln25"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln26"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</a>
<a name="ln27"> * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</a>
<a name="ln28"> * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</a>
<a name="ln29"> * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln30"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln31"> *</a>
<a name="ln32"> * @filename    : appimageupdateinformation_p.cc</a>
<a name="ln33"> * @description : This is where the extraction of embeded update information</a>
<a name="ln34"> * from AppImages is implemented.</a>
<a name="ln35">*/</a>
<a name="ln36">#include &lt;QBuffer&gt;</a>
<a name="ln37">#include &lt;QProcessEnvironment&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &quot;appimageupdateinformation_p.hpp&quot;</a>
<a name="ln40">#include &quot;qappimageupdateenums.hpp&quot;</a>
<a name="ln41"> </a>
<a name="ln42">/*</a>
<a name="ln43"> * An efficient logging system.</a>
<a name="ln44"> * Warning: Hard coded to work only with this class.</a>
<a name="ln45">*/</a>
<a name="ln46">#ifndef LOGGING_DISABLED</a>
<a name="ln47">#define LOGS *(p_Logger.data()) &lt;&lt;</a>
<a name="ln48">#define LOGR &lt;&lt;</a>
<a name="ln49">#define LOGE ; \</a>
<a name="ln50">	     emit(logger(s_LogBuffer , s_AppImagePath)); \</a>
<a name="ln51">	     s_LogBuffer.clear();</a>
<a name="ln52">#else</a>
<a name="ln53">#define LOGS (void)</a>
<a name="ln54">#define LOGR ;(void)</a>
<a name="ln55">#define LOGE ;</a>
<a name="ln56">#endif // LOGGING_DISABLED</a>
<a name="ln57"> </a>
<a name="ln58">#define INFO_START LOGS &quot;   INFO: &quot; LOGR</a>
<a name="ln59">#define INFO_END LOGE</a>
<a name="ln60"> </a>
<a name="ln61">#define WARNING_START LOGS &quot;WARNING: &quot; LOGR</a>
<a name="ln62">#define WARNING_END LOGE</a>
<a name="ln63"> </a>
<a name="ln64">#define FATAL_START LOGS &quot;  FATAL: &quot; LOGR</a>
<a name="ln65">#define FATAL_END LOGE</a>
<a name="ln66"> </a>
<a name="ln67">/*</a>
<a name="ln68"> * Sets the offset and length of the need section header</a>
<a name="ln69"> * from a elf file.</a>
<a name="ln70"> *</a>
<a name="ln71"> * Example:</a>
<a name="ln72"> *      long unsigned offset = 0 , length = 0;</a>
<a name="ln73"> *      ElfXX_Ehdr *elfXX = (ElfXX_Ehdr *) data;</a>
<a name="ln74"> *      ElfXX_Shdr *shdrXX = (ElfXX_Shdr *) (data + elfXX-&gt;e_shoff);</a>
<a name="ln75"> *      strTab = (char *)(data + shdrXX[elfXX-&gt;e_shstrndx].sh_offset);</a>
<a name="ln76"> *      lookupSectionHeaders(strTab , shdr , elf , &quot;.section_header_name&quot; , offset , length , progress);</a>
<a name="ln77"> *</a>
<a name="ln78"> * Note:</a>
<a name="ln79"> * 	progress must be a Qt signal which takes int as a parameter.</a>
<a name="ln80"> */</a>
<a name="ln81">#define lookupSectionHeaders(strTab , shdr , elf , section , offset , length , progsig) \</a>
<a name="ln82">						{ \</a>
<a name="ln83">						for(int i = 0; i &lt; elf-&gt;e_shnum; i++) { \</a>
<a name="ln84">						  emit(progsig((int)((i * 100)/elf-&gt;e_shnum))); \</a>
<a name="ln85">						  QCoreApplication::processEvents(); \</a>
<a name="ln86">						  if(!strcmp(&amp;strTab[shdr[i].sh_name] , section)){ \</a>
<a name="ln87">							  offset = shdr[i].sh_offset; \</a>
<a name="ln88">							  length = shdr[i].sh_size; \</a>
<a name="ln89">							  emit(progsig(80)); \</a>
<a name="ln90">							  break;\</a>
<a name="ln91">						  } \</a>
<a name="ln92">						 }\</a>
<a name="ln93">					        }</a>
<a name="ln94"> </a>
<a name="ln95"> </a>
<a name="ln96"> </a>
<a name="ln97">/*</a>
<a name="ln98"> * AppImage update information positions and magic values.</a>
<a name="ln99"> * See https://github.com/AppImage/AppImageSpec/blob/master/draft.md</a>
<a name="ln100">*/</a>
<a name="ln101">static constexpr auto AppimageType1UpdateInfoPos = 0x8373;</a>
<a name="ln102">static constexpr auto AppimageType1UpdateInfoLen = 0x200;</a>
<a name="ln103">static constexpr auto AppimageType2UpdateInfoShdr = (char*)&quot;.upd_info&quot;;</a>
<a name="ln104">static constexpr char AppimageUpdateInfoDelimiter = 0x7c;</a>
<a name="ln105">static constexpr auto ElfMagicPos = 0x1;</a>
<a name="ln106">static constexpr auto IsoMagicPos = 0x8001;</a>
<a name="ln107">static constexpr auto ElfMagicValueSize= 0x4;</a>
<a name="ln108">static constexpr auto IsoMagicValueSize= 0x6;</a>
<a name="ln109">static const QByteArray ElfMagicValue = &quot;ELF&quot;;</a>
<a name="ln110">static const QByteArray IsoMagicValue = &quot;CD001&quot;;</a>
<a name="ln111"> </a>
<a name="ln112">/*</a>
<a name="ln113"> * e_ident[] identification indexes</a>
<a name="ln114"> * See http://www.sco.com/developers/gabi/latest/ch4.eheader.html</a>
<a name="ln115"> */</a>
<a name="ln116">static constexpr auto EI_CLASS = 0x4; /* file class */</a>
<a name="ln117">static constexpr auto EI_NIDENT = 0x10; /* Size of e_ident[] */</a>
<a name="ln118"> </a>
<a name="ln119">/* e_ident[] file class */</a>
<a name="ln120">static constexpr auto ELFCLASS32 = 0x1; /* 32-bit objs */</a>
<a name="ln121">static constexpr auto ELFCLASS64 = 0x2; /* 64-bit objs */</a>
<a name="ln122"> </a>
<a name="ln123">typedef quint8	Elf_Byte;</a>
<a name="ln124">typedef quint32	Elf32_Addr;	/* Unsigned program address */</a>
<a name="ln125">typedef quint32	Elf32_Off;	/* Unsigned file offset */</a>
<a name="ln126">typedef quint32	Elf32_Sword;	/* Signed large integer */</a>
<a name="ln127">typedef quint32	Elf32_Word;	/* Unsigned large integer */</a>
<a name="ln128">typedef quint16	Elf32_Half;	/* Unsigned medium integer */</a>
<a name="ln129"> </a>
<a name="ln130">typedef quint64	Elf64_Addr;</a>
<a name="ln131">typedef quint64	Elf64_Off;</a>
<a name="ln132">typedef qint32	Elf64_Shalf;</a>
<a name="ln133"> </a>
<a name="ln134">typedef qint64	Elf64_Sword;</a>
<a name="ln135">typedef quint64	Elf64_Word;</a>
<a name="ln136"> </a>
<a name="ln137">typedef qint64	Elf64_Sxword;</a>
<a name="ln138">typedef quint64	Elf64_Xword;</a>
<a name="ln139"> </a>
<a name="ln140">typedef quint32	Elf64_Half;</a>
<a name="ln141">typedef quint16	Elf64_Quarter;</a>
<a name="ln142"> </a>
<a name="ln143">/* ELF Header */</a>
<a name="ln144">typedef struct elfhdr {</a>
<a name="ln145">    unsigned char	e_ident[EI_NIDENT]; /* ELF Identification */</a>
<a name="ln146">    Elf32_Half	e_type;		/* object file type */</a>
<a name="ln147">    Elf32_Half	e_machine;	/* machine */</a>
<a name="ln148">    Elf32_Word	e_version;	/* object file version */</a>
<a name="ln149">    Elf32_Addr	e_entry;	/* virtual entry point */</a>
<a name="ln150">    Elf32_Off	e_phoff;	/* program header table offset */</a>
<a name="ln151">    Elf32_Off	e_shoff;	/* section header table offset */</a>
<a name="ln152">    Elf32_Word	e_flags;	/* processor-specific flags */</a>
<a name="ln153">    Elf32_Half	e_ehsize;	/* ELF header size */</a>
<a name="ln154">    Elf32_Half	e_phentsize;	/* program header entry size */</a>
<a name="ln155">    Elf32_Half	e_phnum;	/* number of program header entries */</a>
<a name="ln156">    Elf32_Half	e_shentsize;	/* section header entry size */</a>
<a name="ln157">    Elf32_Half	e_shnum;	/* number of section header entries */</a>
<a name="ln158">    Elf32_Half	e_shstrndx;	/* section header table's &quot;section</a>
<a name="ln159">					   header string table&quot; entry offset */</a>
<a name="ln160">} Elf32_Ehdr;</a>
<a name="ln161"> </a>
<a name="ln162">typedef struct {</a>
<a name="ln163">    unsigned char	e_ident[EI_NIDENT];	/* Id bytes */</a>
<a name="ln164">    Elf64_Quarter	e_type;			/* file type */</a>
<a name="ln165">    Elf64_Quarter	e_machine;		/* machine type */</a>
<a name="ln166">    Elf64_Half	e_version;		/* version number */</a>
<a name="ln167">    Elf64_Addr	e_entry;		/* entry point */</a>
<a name="ln168">    Elf64_Off	e_phoff;		/* Program hdr offset */</a>
<a name="ln169">    Elf64_Off	e_shoff;		/* Section hdr offset */</a>
<a name="ln170">    Elf64_Half	e_flags;		/* Processor flags */</a>
<a name="ln171">    Elf64_Quarter	e_ehsize;		/* sizeof ehdr */</a>
<a name="ln172">    Elf64_Quarter	e_phentsize;		/* Program header entry size */</a>
<a name="ln173">    Elf64_Quarter	e_phnum;		/* Number of program headers */</a>
<a name="ln174">    Elf64_Quarter	e_shentsize;		/* Section header entry size */</a>
<a name="ln175">    Elf64_Quarter	e_shnum;		/* Number of section headers */</a>
<a name="ln176">    Elf64_Quarter	e_shstrndx;		/* String table index */</a>
<a name="ln177">} Elf64_Ehdr;</a>
<a name="ln178"> </a>
<a name="ln179">/* Section Header */</a>
<a name="ln180">typedef struct {</a>
<a name="ln181">    Elf32_Word	sh_name;	/* name - index into section header</a>
<a name="ln182">					   string table section */</a>
<a name="ln183">    Elf32_Word	sh_type;	/* type */</a>
<a name="ln184">    Elf32_Word	sh_flags;	/* flags */</a>
<a name="ln185">    Elf32_Addr	sh_addr;	/* address */</a>
<a name="ln186">    Elf32_Off	sh_offset;	/* file offset */</a>
<a name="ln187">    Elf32_Word	sh_size;	/* section size */</a>
<a name="ln188">    Elf32_Word	sh_link;	/* section header table index link */</a>
<a name="ln189">    Elf32_Word	sh_info;	/* extra information */</a>
<a name="ln190">    Elf32_Word	sh_addralign;	/* address alignment */</a>
<a name="ln191">    Elf32_Word	sh_entsize;	/* section entry size */</a>
<a name="ln192">} Elf32_Shdr;</a>
<a name="ln193"> </a>
<a name="ln194">typedef struct {</a>
<a name="ln195">    Elf64_Half	sh_name;	/* section name */</a>
<a name="ln196">    Elf64_Half	sh_type;	/* section type */</a>
<a name="ln197">    Elf64_Xword	sh_flags;	/* section flags */</a>
<a name="ln198">    Elf64_Addr	sh_addr;	/* virtual address */</a>
<a name="ln199">    Elf64_Off	sh_offset;	/* file offset */</a>
<a name="ln200">    Elf64_Xword	sh_size;	/* section size */</a>
<a name="ln201">    Elf64_Half	sh_link;	/* link to another */</a>
<a name="ln202">    Elf64_Half	sh_info;	/* misc info */</a>
<a name="ln203">    Elf64_Xword	sh_addralign;	/* memory alignment */</a>
<a name="ln204">    Elf64_Xword	sh_entsize;	/* table entry size */</a>
<a name="ln205">} Elf64_Shdr;</a>
<a name="ln206"> </a>
<a name="ln207">struct AutoBoolCounter {</a>
<a name="ln208">    explicit AutoBoolCounter(bool *p)</a>
<a name="ln209">        : p_Bool(p) {</a>
<a name="ln210">        *p_Bool = true;</a>
<a name="ln211">    }</a>
<a name="ln212">    ~AutoBoolCounter() {</a>
<a name="ln213">        *p_Bool = false;</a>
<a name="ln214">    }</a>
<a name="ln215"> </a>
<a name="ln216">    void lock() {</a>
<a name="ln217">        *p_Bool = true;</a>
<a name="ln218">    }</a>
<a name="ln219"> </a>
<a name="ln220">    void unlock() {</a>
<a name="ln221">        *p_Bool = false;</a>
<a name="ln222">    }</a>
<a name="ln223">  private:</a>
<a name="ln224">    bool *p_Bool = nullptr;</a>
<a name="ln225">};</a>
<a name="ln226"> </a>
<a name="ln227"> </a>
<a name="ln228">/*</a>
<a name="ln229"> * Returns a new QByteArray which contains the contents from the given QFile from the given offset to the given</a>
<a name="ln230"> * max count. This function does not change the position of the QFile.</a>
<a name="ln231"> *</a>
<a name="ln232"> * Example:</a>
<a name="ln233"> * 	QFile file(&quot;Some.AppImage&quot;)</a>
<a name="ln234"> * 	file.open(QIODevice::ReadOnly);</a>
<a name="ln235"> * 	QByteArray data = read(&amp;file , 512 , 1024);</a>
<a name="ln236">*/</a>
<a name="ln237">static QByteArray read(QFile *IO, qint64 offset, qint64 max) {</a>
<a name="ln238">    QByteArray ret;</a>
<a name="ln239">    qint64 before = IO-&gt;pos();</a>
<a name="ln240">    IO-&gt;seek(offset);</a>
<a name="ln241">    ret = IO-&gt;read(max);</a>
<a name="ln242">    IO-&gt;seek(before);</a>
<a name="ln243">    return ret;</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246">static QByteArray readLine(QFile *IO) {</a>
<a name="ln247">    QByteArray ret;</a>
<a name="ln248">    char c = 0;</a>
<a name="ln249">    while(IO-&gt;getChar(&amp;c) &amp;&amp; c != '\n') {</a>
<a name="ln250">        ret.append(c);</a>
<a name="ln251">    }</a>
<a name="ln252">    return ret;</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">// TODO: Evaluate this using Regex instead.</a>
<a name="ln256">static QByteArray getExecPathFromDesktopFile(QFile *file) {</a>
<a name="ln257">    QByteArray line;</a>
<a name="ln258">    qint64 prevPos = file-&gt;pos();</a>
<a name="ln259">    file-&gt;seek(0);</a>
<a name="ln260">    while(!(line = readLine(file)).isEmpty()) {</a>
<a name="ln261">        if(line.contains(&quot;Exec&quot;)) {</a>
<a name="ln262">            for(auto i = 0; i &lt; line.size() ; ++i) {</a>
<a name="ln263">                if(line[i] == '=') {</a>
<a name="ln264">                    line = line.mid(i+1);</a>
<a name="ln265">                    break;</a>
<a name="ln266">                }</a>
<a name="ln267">            }</a>
<a name="ln268">            break;</a>
<a name="ln269">        }</a>
<a name="ln270">    }</a>
<a name="ln271">    file-&gt;seek(prevPos);</a>
<a name="ln272">    return line;</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275"> </a>
<a name="ln276">/*</a>
<a name="ln277"> * AppImageUpdateInformationPrivate is the worker class that provides the ability to easily get the update</a>
<a name="ln278"> * information from an AppImage. This class can be constructed in two ways. The default construct sets the</a>
<a name="ln279"> * QObject parent to be null and creates an empty AppImageUpdateInformationPrivate Object.</a>
<a name="ln280"> *</a>
<a name="ln281"> * Example:</a>
<a name="ln282"> * 	QObject parent;</a>
<a name="ln283"> * 	AppImageUpdateInformationPrivate AppImageInfoWithParent(&amp;parent);</a>
<a name="ln284"> *	AppImageUpdateInformationPrivate AppImageInfoWithoutParent;</a>
<a name="ln285">*/</a>
<a name="ln286">AppImageUpdateInformationPrivate::AppImageUpdateInformationPrivate(QObject *parent)</a>
<a name="ln287">    : QObject(parent) {</a>
<a name="ln288">#ifndef LOGGING_DISABLED</a>
<a name="ln289">    try {</a>
<a name="ln290">        p_Logger.reset(new QDebug(&amp;s_LogBuffer));</a>
<a name="ln291">    } catch ( ... ) {</a>
<a name="ln292">        emit(error(QAppImageUpdateEnums::Error::NotEnoughMemory));</a>
<a name="ln293">        throw;</a>
<a name="ln294">    }</a>
<a name="ln295">#endif // LOGGING_DISABLED</a>
<a name="ln296">    return;</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">/*</a>
<a name="ln300"> * Destructs the AppImageUpdateInformationPrivate , When the user provides the AppImage as a QFile ,</a>
<a name="ln301"> * QFile is not closed , the user is fully responsible to deallocate or close the QFile.</a>
<a name="ln302">*/</a>
<a name="ln303">AppImageUpdateInformationPrivate::~AppImageUpdateInformationPrivate() {</a>
<a name="ln304">    return;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">void AppImageUpdateInformationPrivate::setLoggerName(const QString &amp;name) {</a>
<a name="ln308">    if(b_Busy) {</a>
<a name="ln309">        return;</a>
<a name="ln310">    }</a>
<a name="ln311">#ifndef LOGGING_DISABLED</a>
<a name="ln312">    s_LoggerName = QString(name);</a>
<a name="ln313">#else</a>
<a name="ln314">    (void)name;</a>
<a name="ln315">#endif</a>
<a name="ln316">    return;</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">/*</a>
<a name="ln320"> * This method returns nothing and sets the AppImage referenced by the given QString , The QString is</a>
<a name="ln321"> * expected to be a valid path either an absolute or a relative one. if the path is empty then this</a>
<a name="ln322"> * exits doing nothing.</a>
<a name="ln323"> *</a>
<a name="ln324"> * Example:</a>
<a name="ln325"> * 	AppImageUpdateInformationPrivate AppImageInfo;</a>
<a name="ln326"> * 	AppImageInfo.setAppImage(&quot;PathTo.AppImage&quot;);</a>
<a name="ln327"> *</a>
<a name="ln328"> */</a>
<a name="ln329">void AppImageUpdateInformationPrivate::setAppImage(const QString &amp;AppImagePath) {</a>
<a name="ln330">    if(b_Busy) {</a>
<a name="ln331">        return;</a>
<a name="ln332">    }</a>
<a name="ln333">    clear(); /* clear old data */</a>
<a name="ln334">    if(AppImagePath.isEmpty()) {</a>
<a name="ln335">        WARNING_START  &quot; setAppImage : AppImagePath is empty , operation ignored.&quot; WARNING_END;</a>
<a name="ln336">        return;</a>
<a name="ln337">    }</a>
<a name="ln338">    INFO_START  &quot; setAppImage : &quot; LOGR AppImagePath LOGR &quot;.&quot; INFO_END;</a>
<a name="ln339">    s_AppImagePath = AppImagePath;</a>
<a name="ln340">    s_AppImageName = QFileInfo(AppImagePath).fileName();</a>
<a name="ln341">    return;</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344"> </a>
<a name="ln345">/*</a>
<a name="ln346"> * This is a overloaded method , Sets the AppImage with reference to the given QFile pointer ,</a>
<a name="ln347"> * The given QFile has to be opened and must be readable.</a>
<a name="ln348"> *</a>
<a name="ln349"> * Example:</a>
<a name="ln350"> * 	AppImageUpdateInformationPrivate AppImageInfo;</a>
<a name="ln351"> * 	QFile file(&quot;PathTo.AppImage&quot;);</a>
<a name="ln352"> * 	file.open(QIODevice::ReadOnly);</a>
<a name="ln353"> * 	AppImageInfo.setAppImage(&amp;file);</a>
<a name="ln354"> * 	file.close();</a>
<a name="ln355">*/</a>
<a name="ln356">void AppImageUpdateInformationPrivate::setAppImage(QFile *AppImage) {</a>
<a name="ln357">    if(b_Busy) {</a>
<a name="ln358">        return;</a>
<a name="ln359">    }</a>
<a name="ln360">    clear(); /* clear old data. */</a>
<a name="ln361">    if(!AppImage) {</a>
<a name="ln362">        WARNING_START &quot; setAppImage : given AppImage QFile is nullptr , operation ignored. &quot; WARNING_END</a>
<a name="ln363">        return;</a>
<a name="ln364">    }</a>
<a name="ln365"> </a>
<a name="ln366">    INFO_START  &quot; setAppImage : &quot; LOGR AppImage LOGR &quot;.&quot; INFO_END;</a>
<a name="ln367">    p_AppImage = AppImage;</a>
<a name="ln368">    s_AppImagePath = QFileInfo(AppImage-&gt;fileName()).canonicalFilePath();</a>
<a name="ln369">    s_AppImageName = QFileInfo(s_AppImagePath).fileName();</a>
<a name="ln370">    return;</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373">/*</a>
<a name="ln374"> * If the given bool is true then it connects the logger signal to the</a>
<a name="ln375"> * logPrinter slot to enable debugging messages. On false this disconnects the logPrinter.</a>
<a name="ln376"> *</a>
<a name="ln377"> * Example:</a>
<a name="ln378"> * 	AppImageUpdateInformationPrivate AppImageInfo(&quot;PathTo.AppImage&quot;);</a>
<a name="ln379"> * 	AppImageInfo.setShowLog(true);</a>
<a name="ln380">*/</a>
<a name="ln381">void AppImageUpdateInformationPrivate::setShowLog(bool logNeeded) {</a>
<a name="ln382">    if(b_Busy) {</a>
<a name="ln383">        return;</a>
<a name="ln384">    }</a>
<a name="ln385">#ifndef LOGGING_DISABLED</a>
<a name="ln386">    if(logNeeded) {</a>
<a name="ln387">        connect(this, &amp;AppImageUpdateInformationPrivate::logger,</a>
<a name="ln388">                this, &amp;AppImageUpdateInformationPrivate::handleLogMessage,</a>
<a name="ln389">                Qt::UniqueConnection);</a>
<a name="ln390">        return;</a>
<a name="ln391">    }</a>
<a name="ln392">    disconnect(this, &amp;AppImageUpdateInformationPrivate::logger,</a>
<a name="ln393">               this, &amp;AppImageUpdateInformationPrivate::handleLogMessage);</a>
<a name="ln394">#else</a>
<a name="ln395">    (void)logNeeded;</a>
<a name="ln396">#endif // LOGGING_DISABLED</a>
<a name="ln397">}</a>
<a name="ln398"> </a>
<a name="ln399"> </a>
<a name="ln400">void AppImageUpdateInformationPrivate::getInfo(void) {</a>
<a name="ln401">    if(b_Busy) {</a>
<a name="ln402">        return;</a>
<a name="ln403">    }</a>
<a name="ln404">    AutoBoolCounter bc(&amp;b_Busy);</a>
<a name="ln405"> </a>
<a name="ln406">    /*</a>
<a name="ln407">    * Check if the user called this twice , If so , We don't need to waste our time on calculating the obvious.</a>
<a name="ln408">    * Note: m_Info will always will be empty for a new AppImage , And so if it is not empty then that implies</a>
<a name="ln409">    * that the user called getInfo() twice or more.</a>
<a name="ln410">    */</a>
<a name="ln411">    if(!m_Info.isEmpty()) {</a>
<a name="ln412">        QJsonObject fileInfo = m_Info.value(&quot;FileInformation&quot;).toObject();</a>
<a name="ln413">        emit(operatingAppImagePath(fileInfo.value(&quot;AppImageFilePath&quot;).toString()));</a>
<a name="ln414">        emit(info(m_Info));</a>
<a name="ln415">        return;</a>
<a name="ln416">    }</a>
<a name="ln417"> </a>
<a name="ln418">    /* If this class is constructed without an AppImage to operate on ,</a>
<a name="ln419">     * Then lets guess it. */</a>
<a name="ln420">    if(!p_AppImage &amp;&amp; s_AppImagePath.isEmpty()) {</a>
<a name="ln421">        /* Do not check the QCoreApplication first. First check if the environmental variable</a>
<a name="ln422">        * $APPIMAGE has something , if not then use the arguments given by QCoreApplication. */</a>
<a name="ln423"> </a>
<a name="ln424">        bc.unlock();</a>
<a name="ln425">        setAppImage(QProcessEnvironment::systemEnvironment().value(&quot;APPIMAGE&quot;));</a>
<a name="ln426">        bc.lock();</a>
<a name="ln427"> </a>
<a name="ln428">        // Check if it's a AppImageLauncher's path, if so then use the map file to</a>
<a name="ln429">        // get the actual appimage path.</a>
<a name="ln430">        bool tryUsingProgramArguments = false;</a>
<a name="ln431">        bool checkForAIL = true;</a>
<a name="ln432"> </a>
<a name="ln433">        QRegExp rx(QString::fromUtf8(&quot;/run/user/*/appimagelauncherfs/*.AppImage&quot;));</a>
<a name="ln434">        rx.setPatternSyntax(QRegExp::Wildcard);</a>
<a name="ln435"> </a>
<a name="ln436">        QString desktopIntegration;</a>
<a name="ln437">        if(QProcessEnvironment::systemEnvironment().contains(&quot;DESKTOPINTEGRATION&quot;)) {</a>
<a name="ln438">            desktopIntegration = QProcessEnvironment::systemEnvironment().value(&quot;DESKTOPINTEGRATION&quot;);</a>
<a name="ln439">            INFO_START &quot; getInfo: Desktop integration detected&quot; INFO_END;</a>
<a name="ln440">            if(desktopIntegration == QString::fromStdString(&quot;AppImageLauncher&quot;)) {</a>
<a name="ln441">                INFO_START &quot; getInfo: Desktop integration seems to be AppImageLauncher.&quot; INFO_END;</a>
<a name="ln442">                QString progPath = QProcessEnvironment::systemEnvironment().value(&quot;ARGV0&quot;);</a>
<a name="ln443">                INFO_START &quot; getInfo: ARGV0 = &quot; LOGR progPath INFO_END;</a>
<a name="ln444">                if(!progPath.isEmpty()) {</a>
<a name="ln445">                    bc.unlock();</a>
<a name="ln446">                    setAppImage(progPath);</a>
<a name="ln447">                    bc.lock();</a>
<a name="ln448">                    checkForAIL = false;</a>
<a name="ln449">                }</a>
<a name="ln450">            }</a>
<a name="ln451">        }</a>
<a name="ln452"> </a>
<a name="ln453">        if(checkForAIL &amp;&amp; rx.exactMatch(s_AppImagePath)) {</a>
<a name="ln454">            INFO_START &quot; getInfo: Reading AppImageLauncher internal Map file to get the actual AppImage&quot; INFO_END;</a>
<a name="ln455">            QFileInfo pathInfo(s_AppImagePath);</a>
<a name="ln456">            QString mapPath = pathInfo.absolutePath();</a>
<a name="ln457">            mapPath += QString::fromUtf8(&quot;/map&quot;);</a>
<a name="ln458"> </a>
<a name="ln459">            QString fileID = pathInfo.fileName();</a>
<a name="ln460"> </a>
<a name="ln461">            QFile mapFile(mapPath);</a>
<a name="ln462">            if(mapFile.open(QIODevice::ReadOnly | QIODevice::Text)) {</a>
<a name="ln463">                while (!mapFile.atEnd()) {</a>
<a name="ln464">                    QByteArray line = mapFile.readLine();</a>
<a name="ln465">                    QString str(line);</a>
<a name="ln466">                    auto parts = str.split(QString::fromUtf8(&quot; -&gt; &quot;));</a>
<a name="ln467">                    QString partID = parts.at(0).left(fileID.size());</a>
<a name="ln468">                    if(fileID == partID) {</a>
<a name="ln469">                        // Remove trailling new line</a>
<a name="ln470">                        QString parsedPath = parts.at(1).left(parts.at(1).size() - 1);</a>
<a name="ln471"> </a>
<a name="ln472">                        bc.unlock();</a>
<a name="ln473">                        setAppImage(parsedPath);</a>
<a name="ln474">                        bc.lock();</a>
<a name="ln475">                        break;</a>
<a name="ln476">                    }</a>
<a name="ln477">                    QCoreApplication::processEvents();</a>
<a name="ln478">                }</a>
<a name="ln479">                mapFile.close();</a>
<a name="ln480">            } else {</a>
<a name="ln481">                INFO_START &quot; getInfo: Failed to get the actual AppImage path, trying to use program arguments.&quot; INFO_END;</a>
<a name="ln482">                tryUsingProgramArguments = true; // Try to parse from QCoreApplication.</a>
<a name="ln483">            }</a>
<a name="ln484"> </a>
<a name="ln485">        }</a>
<a name="ln486"> </a>
<a name="ln487">        /*</a>
<a name="ln488">         * Lets try getting it from QCoreApplication arguments. */</a>
<a name="ln489">        if(s_AppImagePath.isEmpty() || tryUsingProgramArguments) {</a>
<a name="ln490">            INFO_START &quot; getInfo: getting the AppImage path from program arguments, This might not work inside firejail.&quot; INFO_END;</a>
<a name="ln491">            auto arguments = QCoreApplication::arguments();</a>
<a name="ln492">            if(!arguments.isEmpty()) {</a>
<a name="ln493">                bc.unlock();</a>
<a name="ln494">                setAppImage(QFileInfo(arguments.at(0)).absolutePath() +</a>
<a name="ln495">                            QString::fromUtf8(&quot;/&quot;) +</a>
<a name="ln496">                            QFileInfo(arguments.at(0)).fileName());</a>
<a name="ln497">                bc.lock();</a>
<a name="ln498">            }</a>
<a name="ln499"> </a>
<a name="ln500">            if(s_AppImagePath.isEmpty() || !QFileInfo::exists(s_AppImagePath)) {</a>
<a name="ln501">                emit(error(QAppImageUpdateEnums::Error::NoAppimagePathGiven));</a>
<a name="ln502">                return;</a>
<a name="ln503">            }</a>
<a name="ln504">        }</a>
<a name="ln505">    }</a>
<a name="ln506"> </a>
<a name="ln507">    emit(operatingAppImagePath(s_AppImagePath));</a>
<a name="ln508"> </a>
<a name="ln509">    if(!p_AppImage) {</a>
<a name="ln510">        /* Open appimage if the user only given the path. */</a>
<a name="ln511">        try {</a>
<a name="ln512">            p_AppImage = new QFile(this);</a>
<a name="ln513">        } catch (...) {</a>
<a name="ln514">            emit(error(QAppImageUpdateEnums::Error::NotEnoughMemory));</a>
<a name="ln515">            return;</a>
<a name="ln516">        }</a>
<a name="ln517"> </a>
<a name="ln518">        /*</a>
<a name="ln519">         * Check if its really a file and not a folder.</a>
<a name="ln520">        */</a>
<a name="ln521">        if(!QFileInfo(s_AppImagePath).isFile()) {</a>
<a name="ln522">            p_AppImage-&gt;deleteLater();</a>
<a name="ln523">            p_AppImage = nullptr;</a>
<a name="ln524">            FATAL_START &quot; setAppImage : cannot use a directory as a file.&quot; FATAL_END;</a>
<a name="ln525">            emit(error(QAppImageUpdateEnums::Error::AppimageNotFound));</a>
<a name="ln526">            return;</a>
<a name="ln527">        }</a>
<a name="ln528"> </a>
<a name="ln529">        p_AppImage-&gt;setFileName(s_AppImagePath);</a>
<a name="ln530"> </a>
<a name="ln531">        QCoreApplication::processEvents();</a>
<a name="ln532"> </a>
<a name="ln533">        /* Check if the file actually exists. */</a>
<a name="ln534">        if(!p_AppImage-&gt;exists()) {</a>
<a name="ln535">            p_AppImage-&gt;deleteLater();</a>
<a name="ln536">            p_AppImage = nullptr;</a>
<a name="ln537">            FATAL_START  &quot; setAppImage : cannot find the AppImage in the given path , file not found.&quot; FATAL_END;</a>
<a name="ln538">            emit(error(QAppImageUpdateEnums::Error::AppimageNotFound));</a>
<a name="ln539">            return;</a>
<a name="ln540">        }</a>
<a name="ln541"> </a>
<a name="ln542">        /* Check if we have the permission to read it. */</a>
<a name="ln543">        auto perm = p_AppImage-&gt;permissions();</a>
<a name="ln544">        if(</a>
<a name="ln545">            !(perm &amp; QFileDevice::ReadUser) &amp;&amp;</a>
<a name="ln546">            !(perm &amp; QFileDevice::ReadGroup) &amp;&amp;</a>
<a name="ln547">            !(perm &amp; QFileDevice::ReadOther)</a>
<a name="ln548">        ) {</a>
<a name="ln549">            p_AppImage-&gt;deleteLater();</a>
<a name="ln550">            p_AppImage = nullptr;</a>
<a name="ln551">            FATAL_START  &quot; setAppImage : no permission(&quot; LOGR perm LOGR &quot;) for reading the given AppImage.&quot; FATAL_END;</a>
<a name="ln552">            emit(error(QAppImageUpdateEnums::Error::NoReadPermission));</a>
<a name="ln553">            return;</a>
<a name="ln554">        }</a>
<a name="ln555"> </a>
<a name="ln556">        /*</a>
<a name="ln557">         * Finally open the file.</a>
<a name="ln558">        */</a>
<a name="ln559">        if(!p_AppImage-&gt;open(QIODevice::ReadOnly)) {</a>
<a name="ln560">            p_AppImage-&gt;deleteLater();</a>
<a name="ln561">            p_AppImage = nullptr;</a>
<a name="ln562">            FATAL_START  &quot; setAppImage : cannot open AppImage for reading.&quot; FATAL_END;</a>
<a name="ln563">            emit(error(QAppImageUpdateEnums::Error::CannotOpenAppimage));</a>
<a name="ln564">            return;</a>
<a name="ln565">        }</a>
<a name="ln566">        QCoreApplication::processEvents();</a>
<a name="ln567"> </a>
<a name="ln568">    } else {</a>
<a name="ln569">        QCoreApplication::processEvents();</a>
<a name="ln570"> </a>
<a name="ln571">        /* Check if exists */</a>
<a name="ln572">        if(!p_AppImage-&gt;exists()) {</a>
<a name="ln573">            FATAL_START  &quot; setAppImage : cannot find the AppImage from given QFile , file does not exists.&quot; FATAL_END;</a>
<a name="ln574">            emit(error(QAppImageUpdateEnums::Error::AppimageNotFound));</a>
<a name="ln575">            return;</a>
<a name="ln576">        }</a>
<a name="ln577"> </a>
<a name="ln578">        /* Check if readable. */</a>
<a name="ln579">        if(!p_AppImage-&gt;isReadable()) {</a>
<a name="ln580">            FATAL_START  &quot; setAppImage : invalid QFile given, not readable.&quot; FATAL_END;</a>
<a name="ln581">            emit(error(QAppImageUpdateEnums::Error::AppimageNotReadable));</a>
<a name="ln582">            return;</a>
<a name="ln583">        }</a>
<a name="ln584"> </a>
<a name="ln585">        /* Check if opened. */</a>
<a name="ln586">        if(!p_AppImage-&gt;isOpen()) {</a>
<a name="ln587">            FATAL_START  &quot; setAppImage : invalid QFile given, not opened.&quot; FATAL_END;</a>
<a name="ln588">            emit(error(QAppImageUpdateEnums::Error::CannotOpenAppimage));</a>
<a name="ln589">            return;</a>
<a name="ln590">        }</a>
<a name="ln591"> </a>
<a name="ln592">        QCoreApplication::processEvents();</a>
<a name="ln593">    }</a>
<a name="ln594"> </a>
<a name="ln595"> </a>
<a name="ln596">    QString AppImageSHA1;</a>
<a name="ln597">    QString updateString;</a>
<a name="ln598">    QStringList data;</a>
<a name="ln599"> </a>
<a name="ln600">    /*</a>
<a name="ln601">     * Read the magic byte , i.e the AI stamp on the given binary. The characters 'AI'</a>
<a name="ln602">     * are hardcoded at the offset 8 with a maximum of 3 characters.</a>
<a name="ln603">     * The 3rd character decides the type of the AppImage.</a>
<a name="ln604">    */</a>
<a name="ln605">    QCoreApplication::processEvents();</a>
<a name="ln606"> </a>
<a name="ln607">    auto magicBytes = read(p_AppImage, /*offset=*/8,/*maxchars=*/ 3);</a>
<a name="ln608">    if (magicBytes[0] != 'A' || magicBytes[1] != 'I') {</a>
<a name="ln609">        /*</a>
<a name="ln610">             * If its not an AppImage then lets check if its a linux desktop file,</a>
<a name="ln611">         * If so then parse the 'Exec' to find the actual AppImage.</a>
<a name="ln612">            */</a>
<a name="ln613">        magicBytes = read(p_AppImage, 0, 15);</a>
<a name="ln614">        if(magicBytes == &quot;[Desktop Entry]&quot;) {</a>
<a name="ln615">            auto path = QString(getExecPathFromDesktopFile(p_AppImage));</a>
<a name="ln616">            if(!path.isEmpty()) {</a>
<a name="ln617">                if(QFileInfo(path).isRelative()) {</a>
<a name="ln618">                    path = QFileInfo(p_AppImage-&gt;fileName()).path() + QString::fromUtf8(&quot;/&quot;) + QString(path);</a>
<a name="ln619">                }</a>
<a name="ln620">                bc.unlock(); /* unlock the bool counter. */</a>
<a name="ln621">                setAppImage(path);</a>
<a name="ln622">                getInfo();</a>
<a name="ln623">                return;</a>
<a name="ln624">            }</a>
<a name="ln625">        }</a>
<a name="ln626"> </a>
<a name="ln627">        FATAL_START  &quot; getInfo : invalid magic bytes(&quot;</a>
<a name="ln628">        LOGR (unsigned)magicBytes[0] LOGR &quot;,&quot;</a>
<a name="ln629">        LOGR (unsigned)magicBytes[1] LOGR &quot;).&quot; FATAL_END;</a>
<a name="ln630">        emit(error(QAppImageUpdateEnums::Error::InvalidMagicBytes));</a>
<a name="ln631">        return;</a>
<a name="ln632">    }</a>
<a name="ln633"> </a>
<a name="ln634">    /*</a>
<a name="ln635">     * Calculate the AppImages SHA1 Hash which will be used later to find if we need to update the</a>
<a name="ln636">     * AppImage.</a>
<a name="ln637">    */</a>
<a name="ln638">    QCoreApplication::processEvents();</a>
<a name="ln639"> </a>
<a name="ln640">    {</a>
<a name="ln641">        qint64 bufferSize = 0;</a>
<a name="ln642">        if(p_AppImage-&gt;size() &gt;= 1073741824) { // 1 GiB and more.</a>
<a name="ln643">            bufferSize = 104857600; // copy per 100 MiB.</a>
<a name="ln644">        } else if(p_AppImage-&gt;size() &gt;= 1048576 ) { // 1 MiB and more.</a>
<a name="ln645">            bufferSize = 1048576; // copy per 1 MiB.</a>
<a name="ln646">        } else if(p_AppImage-&gt;size() &gt;= 1024) { // 1 KiB and more.</a>
<a name="ln647">            bufferSize = 4096; // copy per 4 KiB.</a>
<a name="ln648">        } else { // less than 1 KiB</a>
<a name="ln649">            bufferSize = 1024; // copy per 1 KiB.</a>
<a name="ln650">        }</a>
<a name="ln651"> </a>
<a name="ln652">        QCryptographicHash *SHA1Hasher = new QCryptographicHash(QCryptographicHash::Sha1);</a>
<a name="ln653">        while(!p_AppImage-&gt;atEnd()) {</a>
<a name="ln654">            SHA1Hasher-&gt;addData(p_AppImage-&gt;read(bufferSize));</a>
<a name="ln655">            QCoreApplication::processEvents();</a>
<a name="ln656">        }</a>
<a name="ln657">        p_AppImage-&gt;seek(0); // rewind file to the top for later use.</a>
<a name="ln658">        AppImageSHA1 = QString(SHA1Hasher-&gt;result().toHex().toUpper());</a>
<a name="ln659">        delete SHA1Hasher;</a>
<a name="ln660">    }</a>
<a name="ln661"> </a>
<a name="ln662">    QCoreApplication::processEvents();</a>
<a name="ln663"> </a>
<a name="ln664">    /*</a>
<a name="ln665">     * 0x1H -&gt; Type 1 AppImage.</a>
<a name="ln666">     * 0x2H -&gt; Type 2 AppImage. (Latest Version)</a>
<a name="ln667">    */</a>
<a name="ln668">    int type = (int)magicBytes[2];</a>
<a name="ln669">    if(type == 0x1) {</a>
<a name="ln670">        INFO_START  &quot; getInfo : AppImage is confirmed to be type 1.&quot; INFO_END;</a>
<a name="ln671">        progress(/*percentage=*/80); /*Signal progress.*/</a>
<a name="ln672">        QCoreApplication::processEvents();</a>
<a name="ln673"> </a>
<a name="ln674">        updateString = QString::fromUtf8(read(p_AppImage, AppimageType1UpdateInfoPos, AppimageType1UpdateInfoLen));</a>
<a name="ln675">    } else if(type == 0x2) {</a>
<a name="ln676"> </a>
<a name="ln677">        INFO_START  &quot; getInfo : AppImage is confirmed to be type 2.&quot; INFO_END;</a>
<a name="ln678">        INFO_START  &quot; getInfo : mapping AppImage to memory.&quot; INFO_END;</a>
<a name="ln679"> </a>
<a name="ln680">        {</a>
<a name="ln681">            uint8_t *data = NULL;</a>
<a name="ln682">            char *strTab = NULL;</a>
<a name="ln683">            unsigned long offset = 0, length = 0;</a>
<a name="ln684"> </a>
<a name="ln685">            uchar *mapped = p_AppImage-&gt;map(/*offset=*/0, /*max=*/p_AppImage-&gt;size());</a>
<a name="ln686"> </a>
<a name="ln687">            if(mapped == NULL) {</a>
<a name="ln688">                FATAL_START  &quot; getInfo : not enough memory to map AppImage to memory.&quot; FATAL_END;</a>
<a name="ln689">                emit(error(QAppImageUpdateEnums::Error::NotEnoughMemory));</a>
<a name="ln690">                return;</a>
<a name="ln691">            }</a>
<a name="ln692"> </a>
<a name="ln693">            QCoreApplication::processEvents();</a>
<a name="ln694">            data = (uint8_t*) mapped;</a>
<a name="ln695"> </a>
<a name="ln696">            if((((Elf32_Ehdr*)data)-&gt;e_ident[EI_CLASS] == ELFCLASS32)) {</a>
<a name="ln697">                INFO_START  &quot; getInfo : AppImage architecture is x86 (32 bits).&quot; INFO_END;</a>
<a name="ln698"> </a>
<a name="ln699">                Elf32_Ehdr *elf32 = (Elf32_Ehdr *) data;</a>
<a name="ln700">                Elf32_Shdr *shdr32 = (Elf32_Shdr *) (data + elf32-&gt;e_shoff);</a>
<a name="ln701"> </a>
<a name="ln702">                strTab = (char *)(data + shdr32[elf32-&gt;e_shstrndx].sh_offset);</a>
<a name="ln703"> </a>
<a name="ln704">                lookupSectionHeaders(strTab, shdr32, elf32, AppimageType2UpdateInfoShdr,</a>
<a name="ln705">                                     /*variable to set offset=*/offset, /*length of the header=*/length,</a>
<a name="ln706">                                     /*Progress signal to use=*/progress);</a>
<a name="ln707">            } else if((((Elf64_Ehdr*)data)-&gt;e_ident[EI_CLASS] == ELFCLASS64)) {</a>
<a name="ln708">                INFO_START  &quot; getInfo : AppImage architecture is x86_64 (64 bits).&quot; INFO_END;</a>
<a name="ln709"> </a>
<a name="ln710">                Elf64_Ehdr *elf64 = (Elf64_Ehdr *) data;</a>
<a name="ln711">                Elf64_Shdr *shdr64 = (Elf64_Shdr *) (data + elf64-&gt;e_shoff);</a>
<a name="ln712"> </a>
<a name="ln713">                strTab = (char *)(data + shdr64[elf64-&gt;e_shstrndx].sh_offset);</a>
<a name="ln714">                lookupSectionHeaders(strTab, shdr64, elf64, AppimageType2UpdateInfoShdr,</a>
<a name="ln715">                                     offset, length, progress);</a>
<a name="ln716">            } else {</a>
<a name="ln717">                p_AppImage-&gt;unmap(mapped);</a>
<a name="ln718">                FATAL_START  &quot; getInfo : Unsupported elf format.&quot; FATAL_END;</a>
<a name="ln719">                emit(error(QAppImageUpdateEnums::Error::UnsupportedElfFormat));</a>
<a name="ln720">                return;</a>
<a name="ln721">            }</a>
<a name="ln722"> </a>
<a name="ln723">            p_AppImage-&gt;unmap(mapped);</a>
<a name="ln724"> </a>
<a name="ln725">            if(offset == 0 || length == 0) {</a>
<a name="ln726">                FATAL_START  &quot; getInfo : cannot find '&quot;</a>
<a name="ln727">                LOGR AppimageType2UpdateInfoShdr LOGR &quot;' section header.&quot; FATAL_END;</a>
<a name="ln728">                emit(error(QAppImageUpdateEnums::Error::SectionHeaderNotFound));</a>
<a name="ln729">            } else {</a>
<a name="ln730">                updateString = QString::fromUtf8(read(p_AppImage, offset, length));</a>
<a name="ln731">            }</a>
<a name="ln732">        }</a>
<a name="ln733">    } else {</a>
<a name="ln734">        WARNING_START  &quot; getInfo : unable to confirm AppImage type.&quot; WARNING_END;</a>
<a name="ln735">        if(</a>
<a name="ln736">            (read(p_AppImage, ElfMagicPos, ElfMagicValueSize) == ElfMagicValue) &amp;&amp;</a>
<a name="ln737">            (read(p_AppImage, IsoMagicPos, IsoMagicValueSize) == IsoMagicValue)</a>
<a name="ln738">        ) {</a>
<a name="ln739">            WARNING_START  &quot; getInfo : guessing AppImage type to be 1.&quot; WARNING_END;</a>
<a name="ln740">            emit(progress(80));</a>
<a name="ln741">            updateString = QString::fromUtf8(read(p_AppImage, AppimageType1UpdateInfoPos, AppimageType1UpdateInfoLen));</a>
<a name="ln742">        } else {</a>
<a name="ln743">            FATAL_START  &quot; getInfo : invalid AppImage type(&quot; LOGR type LOGR &quot;).&quot; FATAL_END;</a>
<a name="ln744">            emit(error(QAppImageUpdateEnums::Error::InvalidAppimageType));</a>
<a name="ln745">            return;</a>
<a name="ln746">        }</a>
<a name="ln747">    }</a>
<a name="ln748"> </a>
<a name="ln749">    QCoreApplication::processEvents();</a>
<a name="ln750"> </a>
<a name="ln751">    if(updateString.isEmpty()) {</a>
<a name="ln752">        FATAL_START  &quot; getInfo : update information is empty.&quot; FATAL_END;</a>
<a name="ln753">        emit(error(QAppImageUpdateEnums::Error::EmptyUpdateInformation));</a>
<a name="ln754">        return;</a>
<a name="ln755">    }</a>
<a name="ln756"> </a>
<a name="ln757">    INFO_START &quot; getInfo : updateString(&quot; LOGR updateString LOGR &quot;).&quot; INFO_END;</a>
<a name="ln758"> </a>
<a name="ln759">    /*</a>
<a name="ln760">     * Split the raw update information with the specified</a>
<a name="ln761">     * delimiter.</a>
<a name="ln762">    */</a>
<a name="ln763">    data = updateString.split(AppimageUpdateInfoDelimiter);</a>
<a name="ln764"> </a>
<a name="ln765">    // This will be sent along the update information.</a>
<a name="ln766">    QJsonObject fileInformation {</a>
<a name="ln767">        { &quot;AppImageFilePath&quot;, s_AppImagePath },</a>
<a name="ln768">        { &quot;AppImageSHA1Hash&quot;, AppImageSHA1 }</a>
<a name="ln769">    };</a>
<a name="ln770"> </a>
<a name="ln771">    QJsonObject updateInformation; // will be filled up later on.</a>
<a name="ln772"> </a>
<a name="ln773">    if(data.size() &lt; 2) {</a>
<a name="ln774">        FATAL_START  &quot; getInfo : update information has invalid delimiters.&quot; FATAL_END;</a>
<a name="ln775">        emit(error(QAppImageUpdateEnums::Error::InvalidAppimageType));</a>
<a name="ln776">        return;</a>
<a name="ln777">    } else if(data.size() == 2) {</a>
<a name="ln778">        {</a>
<a name="ln779">            QJsonObject buffer {</a>
<a name="ln780">                { &quot;transport&quot;, data.at(0) },</a>
<a name="ln781">                { &quot;zsyncUrl&quot;, data.at(1) }</a>
<a name="ln782">            };</a>
<a name="ln783">            updateInformation = buffer;</a>
<a name="ln784">        }</a>
<a name="ln785">    } else if(data.size() == 5) {</a>
<a name="ln786">        if(data.at(0) == &quot;gh-releases-zsync&quot;) {</a>
<a name="ln787">            {</a>
<a name="ln788">                QJsonObject buffer {</a>
<a name="ln789">                    {&quot;transport&quot;, data.at(0) },</a>
<a name="ln790">                    {&quot;username&quot;, data.at(1) },</a>
<a name="ln791">                    {&quot;repo&quot;, data.at(2) },</a>
<a name="ln792">                    {&quot;tag&quot;, data.at(3) },</a>
<a name="ln793">                    {&quot;filename&quot;, data.at(4) }</a>
<a name="ln794">                };</a>
<a name="ln795">                updateInformation = buffer;</a>
<a name="ln796">            }</a>
<a name="ln797">        } else if(data.at(0) == &quot;bintray-zsync&quot;) {</a>
<a name="ln798">            {</a>
<a name="ln799">                QJsonObject buffer {</a>
<a name="ln800">                    {&quot;transport&quot;, data.at(0) },</a>
<a name="ln801">                    {&quot;username&quot;, data.at(1) },</a>
<a name="ln802">                    {&quot;repo&quot;, data.at(2) },</a>
<a name="ln803">                    {&quot;packageName&quot;, data.at(3) },</a>
<a name="ln804">                    {&quot;filename&quot;, data.at(4) }</a>
<a name="ln805">                };</a>
<a name="ln806">                updateInformation = buffer;</a>
<a name="ln807">            }</a>
<a name="ln808">        } else {</a>
<a name="ln809">            FATAL_START  &quot; getInfo : unsupported transport mechanism given.&quot; FATAL_END;</a>
<a name="ln810">            emit(error(QAppImageUpdateEnums::Error::UnsupportedTransport));</a>
<a name="ln811">            return;</a>
<a name="ln812">        }</a>
<a name="ln813"> </a>
<a name="ln814">    } else {</a>
<a name="ln815">        FATAL_START &quot; getInfo : update information has invalid number of entries(&quot; LOGR data.size() LOGR &quot;).&quot; FATAL_END;</a>
<a name="ln816">        emit(error(QAppImageUpdateEnums::Error::InvalidAppimageType));</a>
<a name="ln817">        return;</a>
<a name="ln818">    }</a>
<a name="ln819"> </a>
<a name="ln820">    {</a>
<a name="ln821">        QJsonObject buffer {</a>
<a name="ln822">            { &quot;IsEmpty&quot;, updateInformation.isEmpty() },</a>
<a name="ln823">            { &quot;FileInformation&quot;, fileInformation },</a>
<a name="ln824">            { &quot;UpdateInformation&quot;, updateInformation }</a>
<a name="ln825">        };</a>
<a name="ln826">        m_Info = buffer;</a>
<a name="ln827">    }</a>
<a name="ln828"> </a>
<a name="ln829">    emit(progress(100)); /*Signal progress.*/</a>
<a name="ln830">    emit(info(m_Info));</a>
<a name="ln831">    INFO_START  &quot; getInfo : finished.&quot; INFO_END;</a>
<a name="ln832">    return;</a>
<a name="ln833">}</a>
<a name="ln834"> </a>
<a name="ln835">/*</a>
<a name="ln836"> * This clears all the data held in the current object , making it</a>
<a name="ln837"> * reusable.</a>
<a name="ln838"> *</a>
<a name="ln839"> * Example:</a>
<a name="ln840"> * 	AppImageInfo.clear();</a>
<a name="ln841">*/</a>
<a name="ln842">void AppImageUpdateInformationPrivate::clear(void) {</a>
<a name="ln843">    if(b_Busy) {</a>
<a name="ln844">        return;</a>
<a name="ln845">    }</a>
<a name="ln846">    m_Info = QJsonObject(); /* TODO: if QJsonObject has a clear in future , use it instead. */</a>
<a name="ln847">#ifndef LOGGING_DISABLED</a>
<a name="ln848">    s_LogBuffer.clear();</a>
<a name="ln849">#endif</a>
<a name="ln850">    s_AppImagePath.clear();</a>
<a name="ln851">    s_AppImageName.clear();</a>
<a name="ln852">    p_AppImage = nullptr; /* Drop all responsibilities. */</a>
<a name="ln853">    return;</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856">#ifndef LOGGING_DISABLED</a>
<a name="ln857">/* This private slot proxies the log messages from the logger signal to qInfo(). */</a>
<a name="ln858">void AppImageUpdateInformationPrivate::handleLogMessage(QString msg, QString path) {</a>
<a name="ln859">    (void)path;</a>
<a name="ln860">    qInfo().noquote()  &lt;&lt; &quot;[&quot;</a>
<a name="ln861">                       &lt;&lt;  QDateTime::currentDateTime().toString(Qt::ISODate)</a>
<a name="ln862">                       &lt;&lt; &quot;] &quot;</a>
<a name="ln863">                       &lt;&lt; s_LoggerName</a>
<a name="ln864">                       &lt;&lt; &quot;(&quot;</a>
<a name="ln865">                       &lt;&lt; s_AppImageName &lt;&lt; &quot;)::&quot; &lt;&lt; msg;</a>
<a name="ln866">    return;</a>
<a name="ln867">}</a>
<a name="ln868">#endif // LOGGING_DISABLED</a>

</code></pre>
<div class="balloon" rel="613"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v575/" target="_blank">V575</a> The null pointer is passed into 'read' function. Inspect the second argument.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
