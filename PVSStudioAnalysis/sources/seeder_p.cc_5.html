
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>seeder_p.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#ifdef DECENTRALIZED_UPDATE_ENABLED</a>
<a name="ln2">#include &lt;QFileInfo&gt;</a>
<a name="ln3">#include &lt;QDebug&gt;</a>
<a name="ln4">#include &lt;QThread&gt;</a>
<a name="ln5">#include &lt;QCoreApplication&gt;</a>
<a name="ln6">#include &lt;QNetworkProxy&gt;</a>
<a name="ln7">#include &lt;vector&gt;</a>
<a name="ln8">#include &lt;iostream&gt;</a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;helpers_p.hpp&quot;</a>
<a name="ln11">#include &quot;qappimageupdateenums.hpp&quot;</a>
<a name="ln12">#include &quot;seeder_p.hpp&quot;</a>
<a name="ln13"> </a>
<a name="ln14">SeederPrivate::SeederPrivate(QNetworkAccessManager *manager)</a>
<a name="ln15">    : QObject() {</a>
<a name="ln16">    lt::session_params p = lt::session_params();</a>
<a name="ln17">    p.settings.set_int(lt::settings_pack::alert_mask,</a>
<a name="ln18">                       lt::alert_category::status |</a>
<a name="ln19">                       lt::alert_category::error |</a>
<a name="ln20">                       lt::alert_category::storage);</a>
<a name="ln21">    </a>
<a name="ln22">    //// Set proxy for libtorrent.</a>
<a name="ln23">    auto proxy = manager-&gt;proxy();</a>
<a name="ln24">    if(proxy.type() != QNetworkProxy::NoProxy) {</a>
<a name="ln25">	emit logger(&quot;Using proxy for torrent seeding.&quot;);</a>
<a name="ln26">	p.settings.set_str(lt::settings_pack::proxy_hostname,</a>
<a name="ln27">			   proxy.hostName().toStdString());</a>
<a name="ln28">	p.settings.set_int(lt::settings_pack::proxy_port,</a>
<a name="ln29">			   (int)proxy.port());</a>
<a name="ln30">	p.settings.set_str(lt::settings_pack::proxy_username,</a>
<a name="ln31">			   proxy.user().toStdString());</a>
<a name="ln32">	p.settings.set_str(lt::settings_pack::proxy_password,</a>
<a name="ln33">			   proxy.password().toStdString());</a>
<a name="ln34">	</a>
<a name="ln35">	/// Set Proxy type.</a>
<a name="ln36">	if(proxy.type() == QNetworkProxy::Socks5Proxy) {</a>
<a name="ln37">		p.settings.set_int(lt::settings_pack::proxy_type,</a>
<a name="ln38">				   lt::settings_pack::socks5_pw);</a>
<a name="ln39">	}else if(proxy.type() == QNetworkProxy::HttpProxy) {</a>
<a name="ln40">		p.settings.set_int(lt::settings_pack::proxy_type,</a>
<a name="ln41">				   lt::settings_pack::http_pw);</a>
<a name="ln42">	}else{</a>
<a name="ln43">		emit logger(&quot;Cannot find proxy type. Failed to set proxy.&quot;);</a>
<a name="ln44">	}</a>
<a name="ln45">    }</a>
<a name="ln46"> </a>
<a name="ln47">    m_Manager = manager;</a>
<a name="ln48">    m_Session.reset(new lt::session(p));</a>
<a name="ln49">    m_TorrentMeta.reset(new QByteArray);</a>
<a name="ln50"> </a>
<a name="ln51">    m_TimeoutTimer.setSingleShot(true);</a>
<a name="ln52">    m_TimeoutTimer.setInterval(100 * 1000); // 100 seconds</a>
<a name="ln53"> </a>
<a name="ln54">    connect(&amp;m_TimeoutTimer, &amp;QTimer::timeout,</a>
<a name="ln55">            this, &amp;SeederPrivate::handleTimeout,</a>
<a name="ln56">            Qt::QueuedConnection);</a>
<a name="ln57"> </a>
<a name="ln58">    m_Timer.setSingleShot(false);</a>
<a name="ln59">    m_Timer.setInterval(100); // 1ms?</a>
<a name="ln60">    connect(&amp;m_Timer, &amp;QTimer::timeout,</a>
<a name="ln61">            this, &amp;SeederPrivate::torrentLoop,</a>
<a name="ln62">            Qt::QueuedConnection);</a>
<a name="ln63">}</a>
<a name="ln64"> </a>
<a name="ln65">SeederPrivate::~SeederPrivate() {</a>
<a name="ln66">	m_Session-&gt;abort();</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69">void SeederPrivate::start(QJsonObject info) {</a>
<a name="ln70">    if(b_Running) {</a>
<a name="ln71">        return;</a>
<a name="ln72">    }</a>
<a name="ln73">    </a>
<a name="ln74">    if(info.isEmpty()) {</a>
<a name="ln75">	emit error(QAppImageUpdateEnums::Error::ProtocolFailure);</a>
<a name="ln76">        return;</a>
<a name="ln77">    }</a>
<a name="ln78"> </a>
<a name="ln79">    b_Running = false;</a>
<a name="ln80"> </a>
<a name="ln81">    auto embeddedUpdateInformation = info[&quot;EmbededUpdateInformation&quot;].toObject();</a>
<a name="ln82">    auto oldVersionInformation = embeddedUpdateInformation[&quot;FileInformation&quot;].toObject();</a>
<a name="ln83"> </a>
<a name="ln84">    QString remoteTargetFileSHA1Hash = info[&quot;RemoteTargetFileSHA1Hash&quot;].toString(),</a>
<a name="ln85">            localAppImageSHA1Hash = oldVersionInformation[&quot;AppImageSHA1Hash&quot;].toString(),</a>
<a name="ln86">            localAppImagePath = oldVersionInformation[&quot;AppImageFilePath&quot;].toString();</a>
<a name="ln87"> </a>
<a name="ln88">    bool torrentSupported = info[&quot;TorrentSupported&quot;].toBool();</a>
<a name="ln89">    auto torrentFileUrl = info[&quot;TorrentFileUrl&quot;].toString();</a>
<a name="ln90">    auto targetFileName = info[&quot;RemoteTargetFileName&quot;].toString();</a>
<a name="ln91"> </a>
<a name="ln92">    if(localAppImageSHA1Hash != remoteTargetFileSHA1Hash) {</a>
<a name="ln93">	    emit error(QAppImageUpdateEnums::Error::OutdatedAppImageForSeed);</a>
<a name="ln94">	    return;</a>
<a name="ln95">    }</a>
<a name="ln96"> </a>
<a name="ln97">    if(!torrentSupported) {</a>
<a name="ln98">	    emit error(QAppImageUpdateEnums::Error::TorrentNotSupported);</a>
<a name="ln99">	    return;</a>
<a name="ln100">    }</a>
<a name="ln101"> </a>
<a name="ln102">    m_TargetFilePath = localAppImagePath;</a>
<a name="ln103"> </a>
<a name="ln104">    m_TorrentMeta-&gt;clear();</a>
<a name="ln105"> </a>
<a name="ln106">    QNetworkRequest request;</a>
<a name="ln107">    request.setUrl(torrentFileUrl);</a>
<a name="ln108">    request.setAttribute(QNetworkRequest::FollowRedirectsAttribute, true);</a>
<a name="ln109"> </a>
<a name="ln110">    auto reply = m_Manager-&gt;get(request);</a>
<a name="ln111">    connect(reply, SIGNAL(error(QNetworkReply::NetworkError)),</a>
<a name="ln112">            this, SLOT(handleTorrentFileError(QNetworkReply::NetworkError)));</a>
<a name="ln113">    connect(reply, SIGNAL(downloadProgress(qint64, qint64)),</a>
<a name="ln114">            this, SLOT(handleTorrentFileData(qint64, qint64)));</a>
<a name="ln115">    connect(reply, SIGNAL(finished()),</a>
<a name="ln116">            this, SLOT(handleTorrentFileFinish()));</a>
<a name="ln117">    b_Running = true;</a>
<a name="ln118">    emit started();</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121">void SeederPrivate::cancel() {</a>
<a name="ln122">    if(!b_Running || b_CancelRequested) {</a>
<a name="ln123">        return;</a>
<a name="ln124">    }</a>
<a name="ln125">    b_CancelRequested = true;</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">void SeederPrivate::handleTorrentFileError(QNetworkReply::NetworkError code) {</a>
<a name="ln129">    QNetworkReply *reply = qobject_cast&lt;QNetworkReply*&gt;(QObject::sender());</a>
<a name="ln130">    if(!reply) {</a>
<a name="ln131">        return;</a>
<a name="ln132">    }</a>
<a name="ln133"> </a>
<a name="ln134">    reply-&gt;disconnect();</a>
<a name="ln135">    reply-&gt;deleteLater();</a>
<a name="ln136"> </a>
<a name="ln137">    emit error(translateQNetworkReplyError(code));</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140">void SeederPrivate::handleTorrentFileData(qint64 br, qint64 bt) {</a>
<a name="ln141">    Q_UNUSED(br);</a>
<a name="ln142">    Q_UNUSED(bt);</a>
<a name="ln143"> </a>
<a name="ln144">    auto reply = qobject_cast&lt;QNetworkReply*&gt;(QObject::sender());</a>
<a name="ln145">    if(!reply) {</a>
<a name="ln146">        return;</a>
<a name="ln147">    }</a>
<a name="ln148"> </a>
<a name="ln149">    if(reply-&gt;error() != QNetworkReply::NoError) {</a>
<a name="ln150">        return;</a>
<a name="ln151">    }</a>
<a name="ln152"> </a>
<a name="ln153">    if(reply-&gt;isReadable()) {</a>
<a name="ln154">        m_TorrentMeta-&gt;append(reply-&gt;readAll());</a>
<a name="ln155">    }</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158">void SeederPrivate::handleTorrentFileFinish() {</a>
<a name="ln159">    auto reply = qobject_cast&lt;QNetworkReply*&gt;(QObject::sender());</a>
<a name="ln160">    m_TorrentMeta-&gt;append(reply-&gt;readAll());</a>
<a name="ln161"> </a>
<a name="ln162">    reply-&gt;disconnect();</a>
<a name="ln163">    reply-&gt;deleteLater();</a>
<a name="ln164"> </a>
<a name="ln165">    if(b_CancelRequested) {</a>
<a name="ln166">        b_CancelRequested = false;</a>
<a name="ln167">        b_Running = false;</a>
<a name="ln168">        emit canceled();</a>
<a name="ln169">        return;</a>
<a name="ln170">    }</a>
<a name="ln171"> </a>
<a name="ln172">    lt::add_torrent_params params;</a>
<a name="ln173">    QString savePath = QFileInfo(m_TargetFilePath).path() + &quot;/&quot;;</a>
<a name="ln174"> </a>
<a name="ln175">    params.save_path = savePath.toStdString();</a>
<a name="ln176">    auto ti = std::make_shared&lt;lt::torrent_info&gt;(m_TorrentMeta-&gt;constData(), (int)m_TorrentMeta-&gt;size());</a>
<a name="ln177"> </a>
<a name="ln178">    /// We know that MakeAppImageTorrent only packs a single file that is the</a>
<a name="ln179">    /// the Target AppImage. So We just need to check if it is bundled correctly.</a>
<a name="ln180">    if(ti-&gt;num_files() != 1) {</a>
<a name="ln181">        emit error(QNetworkReply::ProtocolFailure);</a>
<a name="ln182">        return;</a>
<a name="ln183">    }</a>
<a name="ln184"> </a>
<a name="ln185">    /// Since only 1 file is packaged in the torrent, we can</a>
<a name="ln186">    /// assume that the file index for our Target AppImage is 0</a>
<a name="ln187">    ti-&gt;rename_file(0,</a>
<a name="ln188">                    QFileInfo(m_TargetFilePath).fileName().toStdString());</a>
<a name="ln189"> </a>
<a name="ln190"> </a>
<a name="ln191">    //ti-&gt;add_url_seed(m_TargetFileUrl.toString().toStdString());</a>
<a name="ln192"> </a>
<a name="ln193">    params.ti = ti;</a>
<a name="ln194">    m_Handle = m_Session-&gt;add_torrent(params);</a>
<a name="ln195">    if(!m_Handle.is_valid()) {</a>
<a name="ln196">        emit error(QAppImageUpdateEnums::Error::ProtocolFailure);</a>
<a name="ln197">        return;</a>
<a name="ln198">    }</a>
<a name="ln199"> </a>
<a name="ln200">    m_Timer.setSingleShot(false);</a>
<a name="ln201">    m_Timer.setInterval(100);</a>
<a name="ln202">    m_Timer.start();</a>
<a name="ln203">    m_TimeoutTimer.start();</a>
<a name="ln204">    return;</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">void SeederPrivate::handleTimeout() {</a>
<a name="ln208">    m_TimeoutTimer.stop();</a>
<a name="ln209"> </a>
<a name="ln210">    emit logger(QString::fromStdString(&quot; handleTimeout: Torrent Seeder Timeout, failing.&quot;));</a>
<a name="ln211">    m_Session-&gt;abort();</a>
<a name="ln212">    b_Running = false;</a>
<a name="ln213">    emit error(QAppImageUpdateEnums::Error::ProtocolFailure);</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">void SeederPrivate::torrentLoop() {</a>
<a name="ln217">    if(!b_Running) {</a>
<a name="ln218">        /// To avoid queued calls from being called</a>
<a name="ln219">        return;</a>
<a name="ln220">    }</a>
<a name="ln221">    if(b_CancelRequested) {</a>
<a name="ln222">        m_TimeoutTimer.stop();</a>
<a name="ln223">        m_Timer.stop();</a>
<a name="ln224">        {</a>
<a name="ln225">	// The destruction of session proxy </a>
<a name="ln226">	// assures that all call writes and everything</a>
<a name="ln227">	// is finished. This is sync.</a>
<a name="ln228">	auto sess_proxy = m_Session-&gt;abort();</a>
<a name="ln229">	}  </a>
<a name="ln230">        b_CancelRequested = false;</a>
<a name="ln231">        b_Running = false;</a>
<a name="ln232">        emit canceled();</a>
<a name="ln233">        return;</a>
<a name="ln234">    }</a>
<a name="ln235">    auto status = m_Handle.status();</a>
<a name="ln236"> </a>
<a name="ln237">    emit torrentStatus(status.num_seeds, status.num_peers);</a>
<a name="ln238">    if(status.state == lt::torrent_status::seeding) {</a>
<a name="ln239">	    m_TimeoutTimer.start();</a>
<a name="ln240">    }</a>
<a name="ln241"> </a>
<a name="ln242">    if(status.state == lt::torrent_status::downloading) {</a>
<a name="ln243">        m_Timer.stop();</a>
<a name="ln244">        m_TimeoutTimer.stop();</a>
<a name="ln245">        {</a>
<a name="ln246">	// The destruction of session proxy </a>
<a name="ln247">	// assures that all call writes and everything</a>
<a name="ln248">	// is finished. This is sync.</a>
<a name="ln249">	auto sess_proxy = m_Session-&gt;abort();</a>
<a name="ln250">	}  </a>
<a name="ln251">        b_Running = false;</a>
<a name="ln252">	emit error(QAppImageUpdateEnums::Error::IncompleteAppImageForSeed);</a>
<a name="ln253">	return;</a>
<a name="ln254">    }</a>
<a name="ln255"> </a>
<a name="ln256">    std::vector&lt;lt::alert*&gt; alerts;</a>
<a name="ln257">    m_Session-&gt;pop_alerts(&amp;alerts);</a>
<a name="ln258">    for (lt::alert const* a : alerts) {</a>
<a name="ln259">        if (lt::alert_cast&lt;lt::torrent_error_alert&gt;(a)) {</a>
<a name="ln260">            emit logger(QString::fromStdString(a-&gt;message()));</a>
<a name="ln261">            m_Timer.stop();</a>
<a name="ln262">            m_TimeoutTimer.stop();</a>
<a name="ln263">	    {</a>
<a name="ln264">		// The destruction of session proxy </a>
<a name="ln265">		// assures that all call writes and everything</a>
<a name="ln266">		// is finished. This is sync.</a>
<a name="ln267">	    	auto sess_proxy = m_Session-&gt;abort();</a>
<a name="ln268">	    }</a>
<a name="ln269">            b_Running = false;</a>
<a name="ln270">            emit error(QNetworkReply::ProtocolFailure);</a>
<a name="ln271">            return;</a>
<a name="ln272">        }</a>
<a name="ln273">        QCoreApplication::processEvents();</a>
<a name="ln274">    }</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">#endif // DECENTRALIZED_UPDATE_ENABLED</a>

</code></pre>
<div class="balloon" rel="79"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1048/" target="_blank">V1048</a> The 'b_Running' variable was assigned the same value.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
