
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>rangedownloader_p.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &lt;QCoreApplication&gt;</a>
<a name="ln2">#include &lt;QThread&gt;</a>
<a name="ln3"> </a>
<a name="ln4">#include &quot;rangedownloader_p.hpp&quot;</a>
<a name="ln5"> </a>
<a name="ln6">RangeDownloaderPrivate::RangeDownloaderPrivate(QNetworkAccessManager *manager, QObject *parent)</a>
<a name="ln7">    : QObject(parent) {</a>
<a name="ln8">    m_Manager = manager;</a>
<a name="ln9">    m_Manager-&gt;clearAccessCache();</a>
<a name="ln10">}</a>
<a name="ln11"> </a>
<a name="ln12">RangeDownloaderPrivate::~RangeDownloaderPrivate() {</a>
<a name="ln13">    if(b_Running) {</a>
<a name="ln14">        for(auto iter = m_ActiveRequests.begin(),</a>
<a name="ln15">                end = m_ActiveRequests.end();</a>
<a name="ln16">                iter != end;</a>
<a name="ln17">                ++iter) {</a>
<a name="ln18">            if(*iter) {</a>
<a name="ln19">                (*iter)-&gt;disconnect();</a>
<a name="ln20">                (*iter)-&gt;destroy();</a>
<a name="ln21">            }</a>
<a name="ln22">        }</a>
<a name="ln23">    }</a>
<a name="ln24">}</a>
<a name="ln25"> </a>
<a name="ln26">/// Public Slots.</a>
<a name="ln27"> </a>
<a name="ln28">void RangeDownloaderPrivate::setBlockSize(qint32 blockSize) {</a>
<a name="ln29">    if(b_Running) {</a>
<a name="ln30">        return;</a>
<a name="ln31">    }</a>
<a name="ln32">    n_BlockSize = blockSize;</a>
<a name="ln33">}</a>
<a name="ln34"> </a>
<a name="ln35">void RangeDownloaderPrivate::setTargetFileUrl(const QUrl &amp;url) {</a>
<a name="ln36">    if(b_Running) {</a>
<a name="ln37">        return;</a>
<a name="ln38">    }</a>
<a name="ln39">    m_Url = url;</a>
<a name="ln40">}</a>
<a name="ln41"> </a>
<a name="ln42">void RangeDownloaderPrivate::setTargetFileLength(qint32 len) {</a>
<a name="ln43">    if(b_Running) {</a>
<a name="ln44">        return;</a>
<a name="ln45">    }</a>
<a name="ln46">    n_TotalSize = len;</a>
<a name="ln47">}</a>
<a name="ln48"> </a>
<a name="ln49">void RangeDownloaderPrivate::setBytesWritten(qint64 len) {</a>
<a name="ln50">    if(b_Running) {</a>
<a name="ln51">        return;</a>
<a name="ln52">    }</a>
<a name="ln53">    n_BytesWritten = len;</a>
<a name="ln54">}</a>
<a name="ln55"> </a>
<a name="ln56">void RangeDownloaderPrivate::setFullDownload(bool fullDownload) {</a>
<a name="ln57">    if(b_Running) {</a>
<a name="ln58">        return;</a>
<a name="ln59">    }</a>
<a name="ln60">    b_FullDownload = fullDownload;</a>
<a name="ln61">}</a>
<a name="ln62"> </a>
<a name="ln63">void RangeDownloaderPrivate::appendRange(qint32 from, qint32 to) {</a>
<a name="ln64">    if(b_Running) {</a>
<a name="ln65">        return;</a>
<a name="ln66">    }</a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69">    m_RequiredBlocks.append(qMakePair&lt;qint32, qint32&gt;(from,to));</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">void RangeDownloaderPrivate::start() {</a>
<a name="ln73">    if(b_Running) {</a>
<a name="ln74">        return;</a>
<a name="ln75">    }</a>
<a name="ln76">    b_Running = b_Finished = false;</a>
<a name="ln77">    n_Active = -1;</a>
<a name="ln78"> </a>
<a name="ln79">    QNetworkRequest request;</a>
<a name="ln80"> </a>
<a name="ln81">    // Before starting the download we have to resolve the url such that it</a>
<a name="ln82">    // does not have any redirections whatsoever.</a>
<a name="ln83">    // For this we send a get request and abort it before it even begin.</a>
<a name="ln84">    // We should not send a HEAD request since it may not be supported by some</a>
<a name="ln85">    // hosts.</a>
<a name="ln86">    request.setUrl(m_Url);</a>
<a name="ln87">    request.setAttribute(QNetworkRequest::FollowRedirectsAttribute, true);</a>
<a name="ln88"> </a>
<a name="ln89">    auto reply = m_Manager-&gt;get(request);</a>
<a name="ln90">    connect(reply, SIGNAL(error(QNetworkReply::NetworkError)),</a>
<a name="ln91">            this, SLOT(handleUrlCheckError(QNetworkReply::NetworkError)));</a>
<a name="ln92">    connect(reply, SIGNAL(downloadProgress(qint64, qint64)),</a>
<a name="ln93">            this, SLOT(handleUrlCheck(qint64, qint64)));</a>
<a name="ln94">    b_Running = true;</a>
<a name="ln95">    emit started();</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">void RangeDownloaderPrivate::cancel() {</a>
<a name="ln99">    if(!b_Running || b_CancelRequested) {</a>
<a name="ln100">        return;</a>
<a name="ln101">    }</a>
<a name="ln102">    b_CancelRequested = true;</a>
<a name="ln103">    for(auto iter = m_ActiveRequests.begin(),</a>
<a name="ln104">            end = m_ActiveRequests.end();</a>
<a name="ln105">            iter != end;</a>
<a name="ln106">            ++iter) {</a>
<a name="ln107">        if(*iter) {</a>
<a name="ln108">            (*iter)-&gt;cancel();</a>
<a name="ln109">        }</a>
<a name="ln110">	QCoreApplication::processEvents();</a>
<a name="ln111">    }</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">/// Private Slots</a>
<a name="ln115">QNetworkRequest RangeDownloaderPrivate::makeRangeRequest(const QUrl &amp;url, const QPair&lt;qint32, qint32&gt; &amp;range) {</a>
<a name="ln116">    QNetworkRequest request;</a>
<a name="ln117"> </a>
<a name="ln118">    request.setUrl(url);</a>
<a name="ln119">    if(range.first || range.second) {</a>
<a name="ln120"> </a>
<a name="ln121">        auto fromRange = range.first * n_BlockSize;</a>
<a name="ln122">        auto toRange = range.second * n_BlockSize;</a>
<a name="ln123"> </a>
<a name="ln124"> </a>
<a name="ln125">        QByteArray rangeHeaderValue = &quot;bytes=&quot; + QByteArray::number(fromRange) + &quot;-&quot;;</a>
<a name="ln126">        rangeHeaderValue += QByteArray::number(toRange);</a>
<a name="ln127">        request.setRawHeader(&quot;Range&quot;, rangeHeaderValue);</a>
<a name="ln128">    }</a>
<a name="ln129">    request.setAttribute(QNetworkRequest::FollowRedirectsAttribute, true);</a>
<a name="ln130">    return request;</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133"> </a>
<a name="ln134">// Slots which does the url check routine</a>
<a name="ln135">void RangeDownloaderPrivate::handleUrlCheckError(QNetworkReply::NetworkError code) {</a>
<a name="ln136">    QNetworkReply *reply = qobject_cast&lt;QNetworkReply*&gt;(QObject::sender());</a>
<a name="ln137">    if(!reply) {</a>
<a name="ln138">        return;</a>
<a name="ln139">    }</a>
<a name="ln140"> </a>
<a name="ln141">    reply-&gt;disconnect();</a>
<a name="ln142">    reply-&gt;deleteLater();</a>
<a name="ln143"> </a>
<a name="ln144">    emit error(code);</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">void RangeDownloaderPrivate::handleUrlCheck(qint64 br, qint64 bt) {</a>
<a name="ln148">    Q_UNUSED(br);</a>
<a name="ln149">    Q_UNUSED(bt);</a>
<a name="ln150"> </a>
<a name="ln151">    auto reply = qobject_cast&lt;QNetworkReply*&gt;(QObject::sender());</a>
<a name="ln152">    if(!reply) {</a>
<a name="ln153">        return;</a>
<a name="ln154">    }</a>
<a name="ln155"> </a>
<a name="ln156">    if(reply-&gt;error() != QNetworkReply::NoError) {</a>
<a name="ln157">        return;</a>
<a name="ln158">    }</a>
<a name="ln159"> </a>
<a name="ln160">    m_Url = reply-&gt;url();</a>
<a name="ln161"> </a>
<a name="ln162">    reply-&gt;disconnect();</a>
<a name="ln163">    reply-&gt;abort();</a>
<a name="ln164">    reply-&gt;deleteLater();</a>
<a name="ln165"> </a>
<a name="ln166">    /// Now we will start the actual download since we got</a>
<a name="ln167">    //  the clean url to the target file.</a>
<a name="ln168"> </a>
<a name="ln169">    /// Amount of bytes downloaded</a>
<a name="ln170">    n_RecievedBytes = 0;</a>
<a name="ln171">    m_ElapsedTimer.start();</a>
<a name="ln172"> </a>
<a name="ln173">    /// If this flag is set then it means we can't use range request and</a>
<a name="ln174">    //  we have to initiate a very simple download.</a>
<a name="ln175">    if(b_FullDownload) {</a>
<a name="ln176">        /// Full download just launch a single RangeReply object.</a>
<a name="ln177">        ++n_Active;</a>
<a name="ln178">        auto range = qMakePair&lt;qint32,qint32&gt;(0,0);</a>
<a name="ln179">        auto rangeReply = new RangeReply(n_Active, m_Manager-&gt;get(makeRangeRequest(m_Url, range)), range);</a>
<a name="ln180"> </a>
<a name="ln181">        connect(rangeReply, SIGNAL(canceled(int)),</a>
<a name="ln182">                this, SLOT(handleRangeReplyCancel(int)),</a>
<a name="ln183">                Qt::QueuedConnection);</a>
<a name="ln184"> </a>
<a name="ln185">        connect(rangeReply, SIGNAL(restarted(int)),</a>
<a name="ln186">                this, SLOT(handleRangeReplyRestart(int)),</a>
<a name="ln187">                Qt::QueuedConnection);</a>
<a name="ln188"> </a>
<a name="ln189">        connect(rangeReply, SIGNAL(error(QNetworkReply::NetworkError, int,bool)),</a>
<a name="ln190">                this, SLOT(handleRangeReplyError(QNetworkReply::NetworkError, int,bool)),</a>
<a name="ln191">                Qt::QueuedConnection);</a>
<a name="ln192"> </a>
<a name="ln193">        connect(rangeReply, SIGNAL(finished(qint32,qint32, QByteArray*, int)),</a>
<a name="ln194">                this, SLOT(handleRangeReplyFinished(qint32,qint32, QByteArray*, int)),</a>
<a name="ln195">                Qt::QueuedConnection);</a>
<a name="ln196"> </a>
<a name="ln197">        connect(rangeReply, SIGNAL(progress(qint64, int)),</a>
<a name="ln198">                this, SLOT(handleRangeReplyProgress(qint64, int)),</a>
<a name="ln199">                Qt::QueuedConnection);</a>
<a name="ln200"> </a>
<a name="ln201">        connect(rangeReply, SIGNAL(data(QByteArray*, bool)),</a>
<a name="ln202">                this, SIGNAL(data(QByteArray*, bool)),</a>
<a name="ln203">                Qt::DirectConnection);</a>
<a name="ln204"> </a>
<a name="ln205">        m_ActiveRequests.append(rangeReply);</a>
<a name="ln206"> </a>
<a name="ln207">        return;</a>
<a name="ln208">    }</a>
<a name="ln209"> </a>
<a name="ln210">    // Now we will determine the maximum no. of requests to be handled at</a>
<a name="ln211">    // a time.</a>
<a name="ln212">    int max_allowed = QThread::idealThreadCount() * 2;</a>
<a name="ln213">    int i = n_Done;</a>
<a name="ln214"> </a>
<a name="ln215">    for(; i &lt; m_RequiredBlocks.size(); ++i) {</a>
<a name="ln216">        if(n_Active + 1 &gt;= max_allowed) {</a>
<a name="ln217">            break;</a>
<a name="ln218">        }</a>
<a name="ln219"> </a>
<a name="ln220">        auto range = m_RequiredBlocks.at(i);</a>
<a name="ln221"> </a>
<a name="ln222">        QNetworkRequest request = makeRangeRequest(m_Url, range);</a>
<a name="ln223">        ++n_Active;</a>
<a name="ln224"> </a>
<a name="ln225">        auto rangeReply = new RangeReply(n_Active, m_Manager-&gt;get(request), range);</a>
<a name="ln226"> </a>
<a name="ln227">        connect(rangeReply, SIGNAL(canceled(int)),</a>
<a name="ln228">                this, SLOT(handleRangeReplyCancel(int)),</a>
<a name="ln229">                Qt::QueuedConnection);</a>
<a name="ln230"> </a>
<a name="ln231">        connect(rangeReply, SIGNAL(restarted(int)),</a>
<a name="ln232">                this, SLOT(handleRangeReplyRestart(int)),</a>
<a name="ln233">                Qt::QueuedConnection);</a>
<a name="ln234"> </a>
<a name="ln235">        connect(rangeReply, SIGNAL(error(QNetworkReply::NetworkError, int,bool)),</a>
<a name="ln236">                this, SLOT(handleRangeReplyError(QNetworkReply::NetworkError, int,bool)),</a>
<a name="ln237">                Qt::QueuedConnection);</a>
<a name="ln238"> </a>
<a name="ln239">        connect(rangeReply, SIGNAL(finished(qint32,qint32, QByteArray*, int)),</a>
<a name="ln240">                this, SLOT(handleRangeReplyFinished(qint32,qint32, QByteArray*, int)),</a>
<a name="ln241">                Qt::QueuedConnection);</a>
<a name="ln242"> </a>
<a name="ln243">        connect(rangeReply, SIGNAL(progress(qint64, int)),</a>
<a name="ln244">                this, SLOT(handleRangeReplyProgress(qint64, int)),</a>
<a name="ln245">                Qt::QueuedConnection);</a>
<a name="ln246"> </a>
<a name="ln247">        m_ActiveRequests.append(rangeReply);</a>
<a name="ln248">    }</a>
<a name="ln249">    n_Done = i;</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">/// ----</a>
<a name="ln253"> </a>
<a name="ln254">/// Range Reply Handlers</a>
<a name="ln255">void RangeDownloaderPrivate::handleRangeReplyCancel(int index) {</a>
<a name="ln256">    (m_ActiveRequests.at(index))-&gt;destroy();</a>
<a name="ln257">    m_ActiveRequests[index] = nullptr;</a>
<a name="ln258">    --n_Active;</a>
<a name="ln259">    if(n_Active == -1) {</a>
<a name="ln260">        b_Running = b_Finished = b_CancelRequested = false;</a>
<a name="ln261">        emit canceled();</a>
<a name="ln262">    }</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265"> </a>
<a name="ln266">void RangeDownloaderPrivate::handleRangeReplyRestart(int index) {</a>
<a name="ln267">    Q_UNUSED(index);</a>
<a name="ln268"> </a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">void RangeDownloaderPrivate::handleRangeReplyError(QNetworkReply::NetworkError code, int index, bool threshReached) {</a>
<a name="ln272">    if(b_CancelRequested) {</a>
<a name="ln273">        (m_ActiveRequests.at(index))-&gt;destroy();</a>
<a name="ln274">        m_ActiveRequests[index] = nullptr;</a>
<a name="ln275">        --n_Active;</a>
<a name="ln276">        if(n_Active == -1) {</a>
<a name="ln277">            b_Running = b_Finished = b_CancelRequested = false;</a>
<a name="ln278">            emit canceled();</a>
<a name="ln279">        }</a>
<a name="ln280">        return;</a>
<a name="ln281">    }</a>
<a name="ln282"> </a>
<a name="ln283"> </a>
<a name="ln284"> </a>
<a name="ln285">    /// Let's try to retry some type of errors.</a>
<a name="ln286">    /// We don't try to retry a full download, if it</a>
<a name="ln287">    /// fails then the update has to be started from the</a>
<a name="ln288">    /// start. This is because even if we try to restart</a>
<a name="ln289">    /// we have to download it from the begining and so</a>
<a name="ln290">    /// It has some complications.</a>
<a name="ln291">    if((code == QNetworkReply::RemoteHostClosedError ||</a>
<a name="ln292">            code == QNetworkReply::HostNotFoundError ||</a>
<a name="ln293">            code == QNetworkReply::TimeoutError ||</a>
<a name="ln294">            code == QNetworkReply::TemporaryNetworkFailureError ||</a>
<a name="ln295">            code == QNetworkReply::BackgroundRequestNotAllowedError ||</a>
<a name="ln296">            code == QNetworkReply::ProxyConnectionClosedError ||</a>
<a name="ln297">            code == QNetworkReply::ProxyTimeoutError ||</a>
<a name="ln298">            code == QNetworkReply::ContentAccessDenied ||</a>
<a name="ln299">            code == QNetworkReply::ContentReSendError ||</a>
<a name="ln300">            code == QNetworkReply::InternalServerError ||</a>
<a name="ln301">            code == QNetworkReply::ServiceUnavailableError) &amp;&amp; !threshReached &amp;&amp; !b_FullDownload) {</a>
<a name="ln302">        (m_ActiveRequests.at(index))-&gt;retry();</a>
<a name="ln303">        return;</a>
<a name="ln304">    } else {</a>
<a name="ln305">        n_Active = -1;</a>
<a name="ln306">        for(auto iter = m_ActiveRequests.begin(),</a>
<a name="ln307">                end = m_ActiveRequests.end();</a>
<a name="ln308">                iter != end;</a>
<a name="ln309">                ++iter) {</a>
<a name="ln310">            if(*iter) {</a>
<a name="ln311">                (*iter)-&gt;disconnect();</a>
<a name="ln312">                (*iter)-&gt;destroy();</a>
<a name="ln313">            }</a>
<a name="ln314">        }</a>
<a name="ln315">        m_ActiveRequests.clear();</a>
<a name="ln316">        b_Running = b_Finished = b_CancelRequested = false;</a>
<a name="ln317">        emit error(code);</a>
<a name="ln318">    }</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321">void RangeDownloaderPrivate::handleRangeReplyFinished(qint32 from, qint32 to, QByteArray *Data, int index) {</a>
<a name="ln322">    (m_ActiveRequests.at(index))-&gt;destroy();</a>
<a name="ln323">    m_ActiveRequests[index] = nullptr;</a>
<a name="ln324"> </a>
<a name="ln325">    if(b_CancelRequested) {</a>
<a name="ln326">        --n_Active;</a>
<a name="ln327">        if(n_Active == -1) {</a>
<a name="ln328">            b_Running = b_Finished = b_CancelRequested = false;</a>
<a name="ln329">            emit canceled();</a>
<a name="ln330">        }</a>
<a name="ln331">        return;</a>
<a name="ln332">    }</a>
<a name="ln333"> </a>
<a name="ln334">    if(b_FullDownload) {</a>
<a name="ln335">        emit data(Data, true);</a>
<a name="ln336">        return;</a>
<a name="ln337">    } else {</a>
<a name="ln338">        bool isLast = (n_Done &gt;= m_RequiredBlocks.size() &amp;&amp; n_Active - 1 == -1);</a>
<a name="ln339">        emit rangeData(from, to,  Data, isLast);</a>
<a name="ln340">    }</a>
<a name="ln341"> </a>
<a name="ln342">    if(n_Done &gt;= m_RequiredBlocks.size()) {</a>
<a name="ln343">        --n_Active;</a>
<a name="ln344">        if(n_Active == -1) {</a>
<a name="ln345">            b_Running = false;</a>
<a name="ln346">            b_Finished = true;</a>
<a name="ln347">            emit finished();</a>
<a name="ln348">        }</a>
<a name="ln349">        return;</a>
<a name="ln350">    }</a>
<a name="ln351"> </a>
<a name="ln352">    auto range = m_RequiredBlocks.at(n_Done++);</a>
<a name="ln353">    QNetworkRequest request = makeRangeRequest(m_Url, range);</a>
<a name="ln354">    auto rangeReply = new RangeReply(index, m_Manager-&gt;get(request), range);</a>
<a name="ln355">    m_ActiveRequests[index] = rangeReply;</a>
<a name="ln356"> </a>
<a name="ln357">    connect(rangeReply, SIGNAL(canceled(int)),</a>
<a name="ln358">            this, SLOT(handleRangeReplyCancel(int)),</a>
<a name="ln359">            Qt::QueuedConnection);</a>
<a name="ln360"> </a>
<a name="ln361">    connect(rangeReply, SIGNAL(restarted(int)),</a>
<a name="ln362">            this, SLOT(handleRangeReplyRestart(int)),</a>
<a name="ln363">            Qt::QueuedConnection);</a>
<a name="ln364"> </a>
<a name="ln365">    connect(rangeReply, SIGNAL(error(QNetworkReply::NetworkError, int, bool)),</a>
<a name="ln366">            this, SLOT(handleRangeReplyError(QNetworkReply::NetworkError, int, bool)),</a>
<a name="ln367">            Qt::QueuedConnection);</a>
<a name="ln368"> </a>
<a name="ln369">    connect(rangeReply, SIGNAL(finished(qint32, qint32, QByteArray*, int)),</a>
<a name="ln370">            this, SLOT(handleRangeReplyFinished(qint32, qint32, QByteArray*, int)),</a>
<a name="ln371">            Qt::QueuedConnection);</a>
<a name="ln372"> </a>
<a name="ln373">    connect(rangeReply, SIGNAL(progress(qint64, int)),</a>
<a name="ln374">            this, SLOT(handleRangeReplyProgress(qint64, int)),</a>
<a name="ln375">            Qt::QueuedConnection);</a>
<a name="ln376"> </a>
<a name="ln377"> </a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">void RangeDownloaderPrivate::handleRangeReplyProgress(qint64 bytesRc, int index) {</a>
<a name="ln381">    Q_UNUSED(index);</a>
<a name="ln382"> </a>
<a name="ln383">    n_RecievedBytes += bytesRc;</a>
<a name="ln384">    qint64 totalBytesRecieved = n_BytesWritten + n_RecievedBytes;</a>
<a name="ln385"> </a>
<a name="ln386">    if(totalBytesRecieved &gt;= n_TotalSize) {</a>
<a name="ln387">        totalBytesRecieved = n_TotalSize;</a>
<a name="ln388">    }</a>
<a name="ln389"> </a>
<a name="ln390">    QString sUnit;</a>
<a name="ln391">    int nPercentage = static_cast&lt;int&gt;(</a>
<a name="ln392">                          (static_cast&lt;float&gt;</a>
<a name="ln393">                           (totalBytesRecieved) * 100.0</a>
<a name="ln394">                          ) / static_cast&lt;float&gt;</a>
<a name="ln395">                          (n_TotalSize)</a>
<a name="ln396">                      );</a>
<a name="ln397"> </a>
<a name="ln398">    double nSpeed =  (n_RecievedBytes) * 1000.0 / m_ElapsedTimer.elapsed();</a>
<a name="ln399">    if (nSpeed &lt; 1024) {</a>
<a name="ln400">        sUnit = &quot;bytes/sec&quot;;</a>
<a name="ln401">    } else if (nSpeed &lt; 1024 * 1024) {</a>
<a name="ln402">        nSpeed /= 1024;</a>
<a name="ln403">        sUnit = &quot;kB/s&quot;;</a>
<a name="ln404">    } else {</a>
<a name="ln405">        nSpeed /= 1024 * 1024;</a>
<a name="ln406">        sUnit = &quot;MB/s&quot;;</a>
<a name="ln407">    }</a>
<a name="ln408">    emit progress(nPercentage, totalBytesRecieved, n_TotalSize, nSpeed, sUnit);</a>
<a name="ln409">}</a>

</code></pre>
<div class="balloon" rel="76"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1048/" target="_blank">V1048</a> The 'b_Running' variable was assigned the same value.</p></div>
<div class="balloon" rel="6"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: n_RecievedBytes.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
